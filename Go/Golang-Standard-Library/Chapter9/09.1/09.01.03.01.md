### 报告方法-总结

- **(1) T 类型内嵌的 common 类型提供这一系列方法，带 `f` 的是格式化的。**
- **(2) 单元测试成功时打印的信息不会输出，可加 `-v` 选项输出这些信息。**

---

- **(1) 遇到断言错误，标识测试失败时**
  - **Fail : 测试失败，测试继续，也就是之后的代码依然会执行**
  - **FailNow : 测试失败，测试中断，内部调用 `runtime.Goexit()` 中断测试**
- **(2) 遇到断言错误，跳过错误，但不标识测试失败时**
  - **SkipNow : 跳过测试，测试中断，内部调用 `runtime.Goexit()` 中断测试**
- **(3) 遇到断言错误，只希望打印信息时**
  - **Log : 输出信息**
  - **Logf : 输出格式化的信息**
- **(4) 遇到断言错误，跳过测试，并且打印出信息时**
  - **Skip : 相当于 Log + SkipNow**
  - **Skipf : 相当于 Logf + SkipNow**
- **(5) 遇到断言错误，标识测试失败，并打印信息，但测试继续时**
  - **Error : 相当于 Log + Fail**
  - **Errorf : 相当于 Logf + Fail**
- **(6) 遇到断言错误，标识测试失败，打印信息，但中断测试时**
  - **Fatal : 相当于 Log + FailNow**
  - **Fatalf : 相当于 Logf + FailNow**

### 报告方法

上面提到的系列包括方法，带 `f` 的是格式化的，格式化语法参考 `fmt` 包。

T 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）：

1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到：

    Fail : 测试失败，测试继续，也就是之后的代码依然会执行
    FailNow : 测试失败，测试中断

在 `FailNow ` 方法实现的内部，是通过调用 `runtime.Goexit()` 来中断测试的。

2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到：

    SkipNow : 跳过测试，测试中断

在 `SkipNow` 方法实现的内部，是通过调用 `runtime.Goexit()` 来中断测试的。

3）当我们只希望打印信息，会用到 :

    Log : 输出信息
    Logf : 输出格式化的信息

注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 `-v` 选项，输出这些信息。但对于基准测试，它们总是会被输出。

4）当我们希望跳过这个测试，并且打印出信息，会用到：

    Skip : 相当于 Log + SkipNow
    Skipf : 相当于 Logf + SkipNow

5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到：

    Error : 相当于 Log + Fail
    Errorf : 相当于 Logf + Fail

6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到：

    Fatal : 相当于 Log + FailNow
    Fatalf : 相当于 Logf + FailNow

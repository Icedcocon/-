# os/signal - 信号-总结

- **(1) Linux 中，1-31 为标准信号；32-64 为实时信号（通过 `kill -l` 可以查看）。**
- **(2) `os/signal` 包可以改变进程收到信号的默认行为。**

# os/signal - 信号

## 基本概念

信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。

因为一个具有合适权限的进程可以向另一个进程发送信号，这可以称为进程间的一种同步技术。当然，进程也可以向自身发送信号。然而，发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下。

* 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令（除 0，引用无法访问的内存区域）。
* 用户键入了能够产生信号的终端特殊字符。如中断字符（通常是  Control-C）、暂停字符（通常是 Control-Z）。
* 发生了软件事件。如调整了终端窗口大小，定时器到期等。

针对每个信号，都定义了一个唯一的（小）整数，从 1 开始顺序展开。系统会用相应常量表示。Linux 中，1-31 为标准信号；32-64 为实时信号（通过 `kill -l` 可以查看）。

信号达到后，进程视具体信号执行如下默认操作之一。

* 忽略信号，也就是内核将信号丢弃，信号对进程不产生任何影响。
* 终止（杀死）进程。
* 产生 coredump 文件，同时进程终止。
* 暂停（Stop）进程的执行。
* 恢复进程执行。

当然，对于有些信号，程序是可以改变默认行为的，这也就是 `os/signal` 包的用途。

兼容性问题：信号的概念来自于 Unix-like 系统。Windows 下只支持 os.SIGINT 信号。
